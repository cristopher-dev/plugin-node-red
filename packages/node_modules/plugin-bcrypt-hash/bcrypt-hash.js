const bcrypt = require('bcrypt');
module.exports = function (RED) {
    // bcrypt-hash
    function BcryptNode(config) {
        RED.nodes.createNode(this, config);
        var node = this;

        node.on('input', async function (msg) {
            if (msg.payload && typeof msg.payload !== 'object') return

            // Obtener la contraseña desde el mensaje
            var password = msg.payload[config.keyHash] || msg.payload

            // Generar un salt (salto) para el hashing
            const saltRounds = Number(config.saltRoundsHash) || 10;

            try {
                // Hashear la contraseña usando bcrypt con await               
                msg.payload.hash = await bcrypt.hash(password, saltRounds);;
                node.send(msg);
            } catch (err) {
                node.error(err.message, msg);
            }
        });
    }

    // bcrypt-compare
    function BcryptCompareNode(config) {
        RED.nodes.createNode(this, config);
        var node = this;

        node.on('input', async function (msg) {
            if (msg.payload && typeof msg.payload !== 'object') return;

            // Get the password and stored hash from the message
            var password = msg.payload[config.passwordCompare] || '';
            var storedHash = msg.payload[config.storedHashCompare] || '';

            // Ensure both password and storedHash are provided
            if (!password || !storedHash) {
                node.error("Missing password or storedHash in the message.", msg);
                return;
            }

            try {
                // Compare the password with the stored hash
                msg.payload.compareResult = await bcrypt.compare(password, storedHash);;
                node.send(msg);
            } catch (err) {
                node.error(err.message, msg);
            }
        });
    }


    RED.nodes.registerType('bcrypt-hash', BcryptNode);
    RED.nodes.registerType('bcrypt-compare', BcryptCompareNode);
};

